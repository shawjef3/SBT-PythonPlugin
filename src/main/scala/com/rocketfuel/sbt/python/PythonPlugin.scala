package com.rocketfuel.sbt.python

import java.util.regex.Pattern
import sbt._

object PythonPlugin extends AutoPlugin {

  val initPy = "__init__.py"

  lazy val pythonBinary = settingKey[File]("Defines the local Python binary to use for compilation, running, and testing.")

  lazy val pythonClassDirectory = settingKey[File]("The directory for compiled Python code.")

  lazy val pythonClean = taskKey[Unit]("Clean the Python target files.")

  lazy val pythonCompile = taskKey[Unit]("Compile python sources.")

  lazy val pythonCopyResources = taskKey[Unit]("Copies resources to the Python output directory.")

  lazy val pythonCreateInits = taskKey[Unit](s"Create $initPy files in each directory.")

  lazy val pythonMakeProducts = taskKey[Seq[File]]("Build products that get packaged.")

  lazy val pythonManagedSourceDirectory = settingKey[File]("Default directory for Python sources generated by the build.")

  lazy val pythonManagedSourceDirectories = settingKey[Seq[File]]("Directories for Python sources generated by the build.")

  lazy val pythonManagedSources = taskKey[Seq[File]]("The list of generated Python sources.")

  lazy val pythonPackageBin = taskKey[File]("Create a zip of the Python binary objects.")

  lazy val pythonPackageSource = taskKey[File]("Contains the Python files to be packaged.")

  lazy val pythonSourceDirectory = settingKey[File]("The directory for manually created Python sources.")

  lazy val pythonTest = taskKey[Unit]("Run Python tests.")

  lazy val pythonUnmanagedSourceDirectories = settingKey[Seq[File]]("Directories for manually created Python sources.")

  lazy val pythonUnmanagedSources = taskKey[Seq[File]]("The list of manually created Python sources.")

  def pythonManagedSourceMappings = Defaults.relativeMappings(pythonManagedSources, pythonManagedSourceDirectories)

  def pythonUnmanagedSourceMappings = Defaults.relativeMappings(pythonUnmanagedSources, pythonUnmanagedSourceDirectories)

  def pythonSourceMappings = Defaults.concatMappings(pythonManagedSourceMappings, pythonUnmanagedSourceMappings)

  def pythonPackageSourceMappings = Defaults.concatMappings(Defaults.resourceMappings, pythonUnmanagedSourceMappings)

  def pythonPackageBinMappings = pythonClassDirectory.map(Path.allSubpaths(_).toSeq)

  lazy val packageSettings: Seq[Def.Setting[_]] =
    Actions.packageTaskSettings(pythonPackageSource, pythonPackageSourceMappings) ++
      Actions.packageTaskSettings(pythonPackageBin, pythonPackageBinMappings)

  lazy val configSettings: Seq[Def.Setting[_]] =
    Seq(
      pythonClassDirectory := Keys.target.value / "python" / (Defaults.prefix(Keys.configuration.value.name) + "classes"),
      pythonSourceDirectory := Keys.sourceDirectory.value / "python",
      pythonUnmanagedSourceDirectories := pythonSourceDirectory.value +: pythonManagedSourceDirectories.value,
      pythonManagedSourceDirectory := Keys.target.value / "python" / "src_managed" / Defaults.nameForSrc(Keys.configuration.value.name),
      pythonManagedSourceDirectories := Seq(pythonManagedSourceDirectory.value),
      Keys.includeFilter in pythonUnmanagedSources := Actions.pyFilter,
      Keys.includeFilter in pythonManagedSources := Actions.pyFilter,
      Keys.managedSourceDirectories <++= pythonManagedSourceDirectories,
      Keys.unmanagedSourceDirectories <++= pythonUnmanagedSourceDirectories,
      Keys.sourceDirectories <++= pythonUnmanagedSourceDirectories,
      Keys.cleanFiles <+= pythonClassDirectory,
      Keys.cleanFiles <++= pythonManagedSourceDirectories,
      pythonUnmanagedSources <<= Defaults.collectFiles(pythonUnmanagedSourceDirectories, Keys.includeFilter in pythonUnmanagedSources, Keys.excludeFilter in pythonUnmanagedSources),
      pythonManagedSources <<= Defaults.collectFiles(pythonManagedSourceDirectories, Keys.includeFilter in pythonManagedSources, Keys.excludeFilter in pythonManagedSources),
      pythonCompile := {
        //create __init__.py files before compiling
        val x0 = pythonCreateInits.value

        Actions.pythonCompile(
          pythonBinary = pythonBinary.value,
          pythonSourceMappings = pythonUnmanagedSourceMappings.value ++ pythonManagedSourceMappings.value,
          pythonClassDirectory = pythonClassDirectory.value,
          logger = Keys.streams.value.log
        )
      },
      pythonMakeProducts := {
        pythonCompile.value
        pythonCopyResources.value

        Seq(pythonClassDirectory.value)
      },
      pythonCreateInits :=
        Actions.pythonInits(pythonUnmanagedSourceMappings.value ++ pythonManagedSourceMappings.value, pythonManagedSourceDirectory.value, Keys.streams.value.log)
    )

  lazy val testSettings: Seq[Setting[_]] = ???

  def allConfigSettings = Seq(
    pythonBinary := Actions.pythonBinaryPath(),
    pythonClean := IO.delete(Keys.target.value / "python")
  )

  override def projectSettings: Seq[Def.Setting[_]] =
    allConfigSettings ++
    inConfig(Compile)(compileSettings) ++
      inConfig(Test)(testSettings)

  object Actions {

    def pythonCompile(
      pythonBinary: File,
      pythonSourceMappings: Seq[(File, String)],
      pythonClassDirectory: File,
      logger: Logger
    ): Unit = {

      val sourceFiles = pythonSourceMappings.map(_._2).toSet

      //Remove files that exist in the target directory, but not in the sources.
      //I.E. it was deleted by the user.
      for (fileToClean <- IO.listFiles(pythonClassDirectory)) {
        val relative = IO.relativize(pythonClassDirectory, fileToClean).get

        if (fileToClean.getName != initPy && ! sourceFiles.contains(relative)) {
          fileToClean.delete()
        }
      }

      for ((source, fileToCopy) <- pythonSourceMappings) {
        val destination = pythonClassDirectory / fileToCopy

        if (!destination.exists() || source.lastModified() > destination.lastModified()) {
          logger.debug(s"Copying modified file $fileToCopy.")
          IO.copyFile(source, destination)
        }
      }

      val compileProcess = Process(Seq(pythonBinary.getAbsolutePath, "-m", "compileall", pythonClassDirectory.getAbsolutePath)).run()
      val exitValue = compileProcess.exitValue()

      if (exitValue != 0) {
        val message = s"python compileall failed with exit code $exitValue."
        sys.error(message)
      }
    }

    /**
      * Create __init__.py files for each directory in pythonSourceMappings.
      *
      * @param pythonSourceMappings
      * @param pythonManagedSourceDirectory
      */
    def pythonInits(
      pythonSourceMappings: Seq[(File, String)],
      pythonManagedSourceDirectory: File,
      logger: Logger
    ): Unit = {
      val initFiles = pythonSourceMappings.map {
        case (_, file) => (pythonManagedSourceDirectory / file).getParentFile / initPy
      } distinct

      for (initFile <- initFiles) {
        logger.debug(s"Creating missing file $initFile.")
        IO.createDirectory(initFile.getParentFile)
        initFile.createNewFile()
      }
    }

    val pyFilter = new PatternFilter(Pattern.compile(".*\\.py"))

    /**
      * List all the .py files in a directory.
      *
      * @param pythonSourceDir
      * @return pairs of a root directory and a file in the directory.
      */
    def listPythonSources(pythonSourceDir: File): Seq[(File, String)] = {
        Path.selectSubpaths(pythonSourceDir, pyFilter).toSeq
    }

    val pycFilter = new PatternFilter(Pattern.compile(".*\\.pyc"))

    /**
      * List all the .pyc files in a directory.
      *
      * @param pythonObjectDir
      * @return
      */
    def listPythonObjects(pythonObjectDir: File): Seq[(File, String)] = {
      Path.selectSubpaths(pythonObjectDir, pycFilter).toSeq
    }

    /**
      * Find the default python executable.
      *
      * @return
      */
    def pythonBinaryPath(): File = {
      val searchCommand =
        if (System.getProperty("os.name").startsWith("Windows")) Seq("where", "python")
        else Seq("which", "python")
      file(Process(searchCommand).lines.head)
    }

    def packageTaskSettings(key: TaskKey[File], mappingsTask: Def.Initialize[Task[Seq[(File, String)]]]): Seq[Def.Setting[_]] =
      inTask(key)(Seq(
        pythonArtifactName := Actions.artifactName,
        Keys.mappings <<= mappingsTask,
        Keys.packageConfiguration <<= Defaults.packageConfigurationTask,
        key in Defaults.TaskGlobal <<= Defaults.packageTask,
        Keys.packagedArtifact := (Keys.artifact.value -> key.value),
        Keys.artifact <<= Defaults.artifactSetting,
        Keys.artifactPath <<= artifactPathSetting(Keys.artifact)
      ))

    def artifactPathSetting(art: SettingKey[Artifact]) = (Keys.target, Keys.projectID, art, pythonArtifactName) {
      (t, module, a, toString) =>
        t / toString(module, a) asFile
    }

    def artifactName(module: ModuleID, artifact: Artifact): String = {
      import artifact._
      val classifierStr = classifier match { case None => ""; case Some(c) => "-" + c }
      artifact.name + "-" + module.revision + classifierStr + "." + artifact.extension
    }

    /**
      * Add the files in a directory to a new zip file.
      *
      * @param pythonClassDirectory is the directory containing files to be zipped.
      * @param destFile             is the zip file to be created.
      * @param logger
      */
    def pythonPackage(
      pythonClassDirectory: File,
      destFile: File,
      logger: Logger
    ): File = {
      import java.nio.file._
      import collection.convert.wrapAll._

      logger.debug(s"Zipping files in ${pythonClassDirectory.getAbsolutePath} to ${destFile.getAbsolutePath}")

      //Create a new zip file.
      val zipURI = new URI("jar:file:" + destFile.getAbsolutePath)
      Files.deleteIfExists(destFile.toPath)
      val zipFs = FileSystems.newFileSystem(zipURI, Map("create" -> "true"))

      val pythonClassesRootPath = pythonClassDirectory.toPath

      /**
        * Get the path of the file in the zip file.
        */
      def relativize(classFile: Path): Path = {
        val zipPath = pythonClassesRootPath.relativize(classFile)
        zipFs.getPath("/").resolve(zipPath.toString)
      }

      val classFiles =
        for (pythonClass <- pythonClassDirectory.***.get.filter(_.isFile)) yield {
          pythonClass.toPath
        }

      for (classFile <- classFiles) {
        val zipPythonSource = relativize(classFile)
        logger.debug(s"Copying $classFile to $destFile:$zipPythonSource")
        Files.copy(classFile, zipPythonSource)
      }

      zipFs.close()

      new File(zipURI)
    }

  }

}
