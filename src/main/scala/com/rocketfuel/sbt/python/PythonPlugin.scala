package com.rocketfuel.sbt.python

import java.nio.file._
import sbt._

object PythonPlugin extends AutoPlugin {

  lazy val python = taskKey[Unit]("Compile python sources.")

  lazy val testPython = taskKey[Unit]("Run Python tests.")

  lazy val pythonSourceRoot = settingKey[File]("The Python source directory.")

  lazy val pythonManagedSourceRoot = settingKey[File]("Directory for Python sources generated by the build.")

  lazy val pythonBinary = taskKey[File]("Defines the local Python binary to use for compilation, running, and testing.")

  lazy val pythonSources = taskKey[Seq[File]]("List the Python source files in pythonSource.")

  lazy val pythonManagedSources = taskKey[Seq[File]]("List the Python source files in pythonManagedSource.")

  lazy val pythonClassDirectory = settingKey[File]("The directory for compiled Python code.")

  lazy val pythonZip = taskKey[Unit]("Zip the compiled Python source files.")

  def rawProjectSettings: Seq[Def.Setting[_]] =
    Seq(
      pythonClassDirectory := Keys.target.value / "python" / (Defaults.prefix(Keys.configuration.value.name) + "classes"),
      pythonSourceRoot := Keys.sourceDirectory.value / "python",
      pythonManagedSourceRoot := Keys.target.value / "python" / "src_managed" / Defaults.nameForSrc(Keys.configuration.value.name),
      pythonSources := listPythonSources(pythonSourceRoot.value, sbt.Keys.streams.value.log),
      pythonManagedSources := listPythonSources(pythonManagedSourceRoot.value, sbt.Keys.streams.value.log),
      Keys.sourceDirectories ++= Seq(pythonSourceRoot.value, pythonManagedSourceRoot.value),
      python := {
        val logger = Keys.streams.value.log
        val pythonSourceV = pythonSourceRoot.value.toPath
        val pythonTargetV = pythonClassDirectory.value.toPath

        IO.delete(pythonTargetV.toFile)

        Files.createDirectories(pythonTargetV)

        val filesToCopy = pythonSources.value

        for (fileToCopy <- filesToCopy.map(_.toPath)) {
          val relative = pythonSourceV.relativize(fileToCopy)
          val destination = pythonTargetV.resolve(relative)
          logger.debug(s"Copying $fileToCopy to $destination.")
          Files.copy(fileToCopy, destination)
        }
      },
      pythonZip := {
        val pythonTargetV = pythonClassDirectory.value
        val pythonSourcesV = pythonTargetV.***.get
        val pythonManagedSourceV = pythonManagedSourceRoot.value
        val pythonManagedSourcesV = pythonManagedSources.value
        val projectName = Keys.name.value
        val projectVersion = Keys.version.value
        val fileSuffix = {
          val configurationName = Keys.configuration.value.name
          if (configurationName == Compile.name) ""
          else "-" + configurationName
        }
        val destFileV = Keys.target.value / "python" / s"$projectName-$projectVersion$fileSuffix.zip"
        val loggerV = Keys.streams.value.log

        zipFiles(pythonTargetV, pythonSourcesV, pythonManagedSourceV, pythonManagedSourcesV, destFileV, loggerV)
      },
      pythonZip <<= pythonZip.dependsOn(python)
    )

  override def projectSettings: Seq[Def.Setting[_]] =
    inConfig(Compile)(rawProjectSettings) ++
      inConfig(Test)(rawProjectSettings) ++ Seq(
      pythonBinary := pythonBinaryPath(Keys.streams.value.log)
    )

  /**
    * List all the .py files in a directory.
    *
    * @param pythonSourceDir
    * @return
    */
  def listPythonSources(pythonSourceDir: File, logger: Logger): Seq[File] = {
    logger.debug(s"looking for py files in $pythonSourceDir")
    if (Files.exists(pythonSourceDir.toPath)) {
      pythonSourceDir ** "*.py" get
    } else Seq.empty
  }

  /**
    * Find the default python executable.
    *
    * @return
    */
  def pythonBinaryPath(logger: Logger): File = {
    val searchCommand =
      if (System.getProperty("os.name").startsWith("Windows")) Seq("where", "python")
      else Seq("which", "python")
    file(Process(searchCommand).lines.head)
  }

  /**
    * Add the files in pythonSources to a new zip file, destFile.
    *
    * @param pythonSourceRoot The python source directory. Usually src/main/python.
    * @param pythonSources The list of files to be added to the zip.
    * @param destFile The zip file to be created.
    * @param logger
    */
  def zipFiles(
    pythonSourceRoot: File,
    pythonSources: Seq[File],
    pythonManagedSourceRoot: File,
    pythonManagedSources: Seq[File],
    destFile: File,
    logger: Logger
  ): Unit = {
    import collection.convert.wrapAll._

    //Create a new zip file.
    val zipURI = new URI("jar:file:" + destFile.getAbsolutePath)
    Files.deleteIfExists(destFile.toPath)
    val zipFs = FileSystems.newFileSystem(zipURI, Map("create" -> "true"))

    /**
      * Get the path of the file in the zip file.
      */
    def relativize(pythonSourceRoot: Path, pythonSource: Path): Path = {
      val zipPath = pythonSourceRoot.relativize(pythonSource)
      zipFs.getPath("/").resolve(zipPath.toString)
    }

    val sourcesAndRoots =
      pythonSources.map(_.toPath).zip(Stream.continually(pythonSourceRoot.toPath)) ++
        pythonManagedSources.map(_.toPath).zip(Stream.continually(pythonManagedSourceRoot.toPath))

    for ((sourceFile, sourceRoot) <- sourcesAndRoots) {
      if (Files.isRegularFile(sourceFile)) {
        val zipPythonSource = relativize(sourceRoot, sourceFile)
        logger.info(s"Copying $sourceFile to $destFile:$zipPythonSource")
        Files.copy(sourceFile, zipPythonSource)
      }
    }

    zipFs.close()
  }

}
