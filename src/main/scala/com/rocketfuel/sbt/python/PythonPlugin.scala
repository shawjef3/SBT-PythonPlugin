package com.rocketfuel.sbt.python

import sbt._

object PythonPlugin extends AutoPlugin {

  lazy val python = taskKey[Unit]("Compile python sources.")

  lazy val testPython = taskKey[Unit]("Run Python tests.")

  lazy val pythonSourceDirectory = settingKey[File]("The Python source directory.")

  lazy val pythonSourceManaged = settingKey[File]("Default directory for Python sources generated by the build.")

  lazy val pythonManagedSourceDirectories = settingKey[Seq[File]]("Directories for Python sources generated by the build.")

  lazy val pythonBinary = taskKey[File]("Defines the local Python binary to use for compilation, running, and testing.")

  lazy val pythonCompileAll = settingKey[Boolean]("Run compileall on the Python sources.")

  lazy val pythonClassDirectory = settingKey[File]("The directory for compiled Python code.")

  lazy val pythonZip = taskKey[Unit]("Zip the compiled Python source files.")

  def rawProjectSettings: Seq[Def.Setting[_]] =
    Seq(
      pythonCompileAll := true,
      pythonClassDirectory := Keys.target.value / "python" / (Defaults.prefix(Keys.configuration.value.name) + "classes"),
      pythonSourceDirectory := Keys.sourceDirectory.value / "python",
      pythonSourceManaged := Keys.target.value / "python" / "src_managed" / Defaults.nameForSrc(Keys.configuration.value.name),
      pythonManagedSourceDirectories := Seq(pythonSourceManaged.value),
      Keys.managedSourceDirectories ++= pythonManagedSourceDirectories.value,
      Keys.sourceDirectories <+= pythonSourceDirectory,
      Keys.sourceDirectories <++= pythonManagedSourceDirectories,
      Keys.cleanFiles <+= pythonClassDirectory,
      Keys.cleanFiles <++= pythonManagedSourceDirectories,
      python := {
        val logger = Keys.streams.value.log
        val pythonTargetV = pythonClassDirectory.value

        IO.delete(pythonTargetV)
        IO.createDirectory(pythonTargetV)

        def copyFile(root: File, fileToCopy: File): Unit = {
          val relative = IO.relativize(root, fileToCopy).get
          val destination = new File(pythonTargetV, relative)
          logger.debug(s"Copying $fileToCopy to $destination.")
          IO.copyFile(fileToCopy, destination)
        }

        val allPythonSourceDirectories = pythonSourceDirectory.value +: pythonManagedSourceDirectories.value

        for ((root, fileToCopy) <- listPythonSources(allPythonSourceDirectories, logger)) {
          copyFile(root, fileToCopy)
        }

        val compileProcess = Process(Seq(pythonBinary.value.getAbsolutePath, "-m" , "compileall", pythonTargetV.getAbsolutePath)).run()
        val exitValue = compileProcess.exitValue()

        if (exitValue != 0) {
          val message = s"python compileall failed with exit code $exitValue."
          sys.error(message)
        }
      },
      pythonZip := {
        val pythonClassDirectoryV = pythonClassDirectory.value
        val projectName = Keys.name.value
        val projectVersion = Keys.version.value
        val fileSuffix = {
          val configurationName = Keys.configuration.value.name
          if (configurationName == Compile.name) ""
          else "-" + configurationName
        }
        val destFileV = Keys.target.value / "python" / s"$projectName-$projectVersion$fileSuffix.zip"
        val loggerV = Keys.streams.value.log

        zipFiles(pythonClassDirectoryV, destFileV, loggerV)
      },
      pythonZip <<= pythonZip.dependsOn(python)
    )

  override def projectSettings: Seq[Def.Setting[_]] =
    inConfig(Compile)(rawProjectSettings) ++
      inConfig(Test)(rawProjectSettings) ++ Seq(
      pythonBinary := pythonBinaryPath()
    )

  /**
    * List all the .py files in some directories.
    *
    * @param pythonSourceDirs
    * @return pairs of a root directory and a file in the directory.
    */
  def listPythonSources(pythonSourceDirs: Seq[File], logger: Logger): Seq[(File, File)] = {
    for {
      pythonSourceDir <- pythonSourceDirs
      if pythonSourceDir.exists()
      _ = logger.debug(s"looking for py files in $pythonSourceDir")
      pythonFile <- pythonSourceDir ** "*.py" get
    } yield (pythonSourceDir, pythonFile)
  }

  /**
    * Find the default python executable.
    *
    * @return
    */
  def pythonBinaryPath(): File = {
    val searchCommand =
      if (System.getProperty("os.name").startsWith("Windows")) Seq("where", "python")
      else Seq("which", "python")
    file(Process(searchCommand).lines.head)
  }

  /**
    * Add the files in a directory to a new zip file.
    *
    * @param pythonClassDirectory is the directory containing files to be zipped.
    * @param destFile is the zip file to be created.
    * @param logger
    */
  def zipFiles(
    pythonClassDirectory: File,
    destFile: File,
    logger: Logger
  ): Unit = {
    import java.nio.file._
    import collection.convert.wrapAll._

    //Create a new zip file.
    val zipURI = new URI("jar:file:" + destFile.getAbsolutePath)
    Files.deleteIfExists(destFile.toPath)
    val zipFs = FileSystems.newFileSystem(zipURI, Map("create" -> "true"))

    val pythonClassesRootPath = pythonClassDirectory.toPath

    /**
      * Get the path of the file in the zip file.
      */
    def relativize(classFile: Path): Path = {
      val zipPath = pythonClassesRootPath.relativize(classFile)
      zipFs.getPath("/").resolve(zipPath.toString)
    }

    val classFiles =
      for (pythonClass <- pythonClassDirectory.***.get.filter(_.isFile)) yield {
        pythonClass.toPath
      }

    for (classFile <- classFiles) {
      val zipPythonSource = relativize(classFile)
      logger.debug(s"Copying $classFile to $destFile:$zipPythonSource")
      Files.copy(classFile, zipPythonSource)
    }

    zipFs.close()
  }

}
